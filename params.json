{
  "name": "Schemagen-graphql",
  "tagline": "GraphQL-Java add-on that adds support for Schema Generation & Execution for enterprise level applications.",
  "body": "Java GraphQL Schema Generation and Execution Framework\r\n========\r\nThe versioning follows [Semantic Versioning](http://semver.org).\r\n[![Build Status](https://travis-ci.org/bpatters/schemagen-graphql.svg?branch=master)](https://travis-ci.org/bpatters/schemagen-graphql)\r\n[![Latest Release](https://maven-badges.herokuapp.com/maven-central/com.bretpatterson/schemagen-graphql/badge.svg)](https://maven-badges.herokuapp.com/maven-central/com.bretpatterson/schemagen-graphql/)\r\n\r\n# Table of Contents\r\n- [Overview](#overview)\r\n- [Dependencies](#dependencies)\r\n- [Hello World](#hello-world)\r\n- [Basic Concepts](#basic-concepts)\r\n- [GraphQL Controllers](#graphql-controllers)\r\n- [Type Mappers](#type-mappers)\r\n\r\n### Overview\r\n\r\nThis is a java to GraphQL schema generation and execution package. This originated the week of January 18th, 2016 as a HackWeek \r\nproject I worked on.  The goal of this is a production level quality project that can be used to build\r\na Java based GraphQL server. \r\nThe following principles will guide this projects evolution:\r\n\r\n- An un-opinionated view of the container the server will use.\r\n- An un-opinionated view of the serialization model you will be using\r\n- Sensible defaults so that setup is extremely easy and straightforward\r\n- Extensible enough to handle the most extreme Enterprise scenarios\r\n- A minimal set of dependencies to utilize the framework.\r\n\r\nInitial Versions will have a base version of Java 7 and require the Guava Module. Future versions will possibly be based on Java 8 and\r\npossibly require the Guava module (TBD).\r\n\r\n### Dependencies\r\n\r\n- Guava (regardless if you include the guava type mapping package)\r\n- SLF4J (logging)\r\n- GraphQL-Java\r\n\r\n\r\n### Hello World\r\n\r\nThe Hello World program below is the simplest GraphQL server you can write. It exposes the GraphQL schema as a CLI\r\nthat you can run from the command line.\r\n\r\nHere is a simple hello world usage scenario\r\n\r\n```java\r\n\r\npackage com.bretpatterson.schemagen.graphql.examples;\r\n\r\nimport com.bretpatterson.schemagen.graphql.annotations.GraphQLQuery;\r\nimport com.bretpatterson.schemagen.graphql.annotations.GraphQLController;\r\nimport com.fasterxml.jackson.databind.ObjectMapper;\r\nimport com.google.common.collect.ImmutableList;\r\nimport com.bretpatterson.schemagen.graphql.GraphQLSchemaBuilder;\r\nimport com.bretpatterson.schemagen.graphql.examples.common.JacksonTypeFactory;\r\n\r\nimport graphql.ExecutionResult;\r\nimport graphql.GraphQL;\r\nimport graphql.schema.GraphQLSchema;\r\n\r\n/**\r\n * This is a hello world example of a graphQL query CLI\r\n */\r\n@GraphQLController\r\npublic class HelloWorld {\r\n\r\n\t@GraphQLQuery(name=\"helloWorld\")\r\n\tpublic String helloWorld() {\r\n\r\n\t\treturn \"Hello World!\";\r\n\t}\r\n\r\n\tpublic static void main(String[] args) throws Exception {\r\n\t\t// the object that we want to expose it's methods as queries\r\n\t\tHelloWorld helloWorld = new HelloWorld();\r\n\t\t// we use a Jackson object mapper object for serialization of values\r\n\t\tObjectMapper objectMapper = new ObjectMapper();\r\n\t\tGraphQLSchema schema = GraphQLSchemaBuilder.newBuilder()\r\n\t\t\t\t// register an object mappper so that parameter datatypes can be deserialized for method invocation\r\n\t\t\t\t.registerTypeFactory(new JacksonTypeFactory(objectMapper))\r\n\t\t\t\t// register the instance of Hello World as our query handler\r\n\t\t\t\t.registerGraphQLControllerObjects(ImmutableList.<Object>of(helloWorld))\r\n\t\t\t\t.build();\r\n\r\n\t\tString queryString = \"{ helloWorld }\";\r\n\r\n\t\tif (args.length > 0) {\r\n\t\t\tqueryString = args[0];\r\n\t\t}\r\n\r\n\t\t// now lets execute a query against the schema\r\n\t\tExecutionResult result = new GraphQL(schema).execute(queryString);\r\n\t\tif (result.getErrors().size() != 0) {\r\n\t\t\t// if there are any errors serialize them using jackson and write them to stderr\r\n\t\t\tSystem.err.println(objectMapper.writeValueAsString(result.getErrors()));\r\n\t\t} else {\r\n\t\t\t// output your response as JSON serialized data\r\n\t\t\tSystem.out.println(objectMapper.writeValueAsString(result.getData()));\r\n\t\t}\r\n\t}\r\n}\r\n\r\n```\r\n### Basic Concepts\r\n\r\n> GraphQL is a data query language and runtime designed and used at Facebook to request and deliver data to mobile and web apps since 2012.\r\n\r\nSchemagen GraphQL is a package that allows you to turn POJO's into a GraphQL Queryable set of objects. Typically these objects consist of two types:\r\n- Objects with methods that perform Queries or Mutations\r\n- Plain Data Objects used as return values and/or Parameters to Queries/Mutations.\r\n\r\nQueryable objects are POJO's where the class is annotated with [@GraphQLController](https://github.com/bpatters/schemagen-graphql/blob/master/src/main/java/com/bretpatterson/schemagen/graphql/annotations/GraphQLController.java) which signals that it contains methods annotated with [@GraphQLQuery](https://github.com/bpatters/schemagen-graphql/blob/master/src/main/java/com/bretpatterson/schemagen/graphql/annotations/GraphQLQuery.java) or [@GraphQLMutation](https://github.com/bpatters/schemagen-graphql/blob/master/src/main/java/com/bretpatterson/schemagen/graphql/annotations/GraphQLMutation.java). These objects have their annotated methods exposed as top level GraphQL fields as Queries or Mutations. \r\n\r\nPlain Data Objects are used to pass data back and forth between the server and the front end code. These require no annotations, but do need to be strongly typed and adhere to the limitations of GraphQL data types. For Java code this primarily means Maps must have Enum's as keys or must not be used at all. This is because Maps are transformed into objects as schema generation time and the keys must be a finite set of known possible values so they can be converted into property fields.\r\n\r\nSchemagen-GraphQL can convert most objects into sensible GraphQL data types, however, it sometimes needs help for objects that you need mapped in a custom manner. This is accomplished by writing custom [Type Mappers](#type-mappers).\r\n\r\n\r\nSensible defaults are provided for most things. However, there are a things that you must provide:\r\n- ITypeFactory \r\n-- You must provide an object that knows how to convert objects from GraphQL generic deserialized parameters into Java specific types. The examples package provides a simple [Jackson based Type Factory](https://github.com/bpatters/schemagen-graphql/blob/master/schemagen-graphql-examples/src/main/java/com/bretpatterson/schemagen/graphql/examples/common/JacksonTypeFactory.java).\r\n- [@GraphQLController annotated objects](https://github.com/bpatters/schemagen-graphql/blob/master/src/main/java/com/bretpatterson/schemagen/graphql/annotations/GraphQLController.java)\r\n-- with [@GraphQLQuery annotated methods](https://github.com/bpatters/schemagen-graphql/blob/master/src/main/java/com/bretpatterson/schemagen/graphql/annotations/GraphQLQuery.java)\r\n-- with [@GraphQLMutation annotated methods](https://github.com/bpatters/schemagen-graphql/blob/master/src/main/java/com/bretpatterson/schemagen/graphql/annotations/GraphQLMutation.java)\r\n\r\n\r\nTo build your schema you use the [GraphQLSchemaBuilder](https://github.com/bpatters/schemagen-graphql/blob/master/src/main/java/com/bretpatterson/schemagen/graphql/GraphQLSchemaBuilder.java) in conjunction with the required objects above. To create your GraphQL schema do the following:\r\n\r\n```java\r\n\r\nGraphQLSchemaBuilder schemaBuilder = GraphQLSchemaBuilder.newBuilder();\r\n\r\n// First register your Type Factory so your Schema knows how to convert query/mutation parameters received into java types.\r\nschemaBuilder.registerTypeFactory(new JacksonTypeFactory(objectMapper));\r\n\r\n// Next pass in a list of Controller objects that you want to use to expose Queries and Mutations through.\r\n// register the instance of Hello World as our query handler\r\n.registerGraphQLControllerObjects(ImmutableList.<Object>of(helloWorld))\r\n\r\n\r\n// Finally Build your GraphQL schema\r\nGraphQLSchema schema - schemaBuilder.build();\r\n```\r\n\r\nThat's all!\r\n\r\nNow it's up to you as to how you expose your schema to the outside world, but assuming you have a query string you want to execute within your schema you can run the schema using:\r\n\r\n```java\r\n\r\nExecutionResult result = new GraphQL(schema).execute(queryString);\r\n\r\n```\r\n\r\nThat's it! Any errors encountered can be obtained via ```result.getErrors()```  and your data results can be obtained via the ```result.getData()```.\r\n\r\n\r\n\r\n### GraphQL Controllers\r\n\r\nGraphQL Controllers are how you expose Top level Queries and Mutations via the GraphQL schema. These objects contain three types of annotations:\r\n[@GraphQLController ](https://github.com/bpatters/schemagen-graphql/blob/master/src/main/java/com/bretpatterson/schemagen/graphql/annotations/GraphQLController.java)\r\n-- with [@GraphQLQuery annotated methods](https://github.com/bpatters/schemagen-graphql/blob/master/src/main/java/com/bretpatterson/schemagen/graphql/annotations/GraphQLQuery.java)\r\n-- with [@GraphQLMutation annotated methods](https://github.com/bpatters/schemagen-graphql/blob/master/src/main/java/com/bretpatterson/schemagen/graphql/annotations/GraphQLMutation.java)\r\n\r\n#### @GraphQLController annotation\r\nThis annotation identifies the type as a controller and optionally specifies a rootObjectName to wrapper it's query in at the top level. \r\nFor example if you take the following class:\r\n\r\n```java \r\n\r\n@GraphQLController\r\npublic class KeyValueStoreController {\r\n  @GraphQLIgnore\r\n  private Map<String,String> dataStore;\r\n  \r\n  @GraphQLQuery(name=\"get\")\r\n  public String getValue(String key) {\r\n     return dataStore.get(key);\r\n  }\r\n  \r\n  @GraphQLMutation(name=\"put\")\r\n  public String setValue(String key, String value) {\r\n  \tdataStore.put(key,value);\r\n  \t\r\n  \treturn value;\r\n  }\r\n}\r\n```\r\n\r\nThis class exposes a simple key -> value store via GraphQL. There is one query operation, get, and one mutation operation named put. The ```@GraphQLQuery``` and ```@GraphQLMutation``` annotations by default will name the filed the name of the method. However in this case we have chosen to rename the field exposed for the query and mutations respectively to \"get\" and \"put\". \r\n\r\nYou can then store key/values using:\r\n```mutation Store { put(key:\"key1\", value:\"value1\") }```\r\nwhich outputs: ```{\"put\":\"value1\"}```\r\n\r\nYou could then retrieve the value with:\r\n```query MyQuery { get(key:\"key1\") }```\r\nwhich outputs: ```{\"get\":\"value1\"}```\r\n\r\nYou can also do schema queries like:\r\n``` \r\n{\r\n  __schema {\r\n    queryType {\r\n      name,\r\n      fields {\r\n        name\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nwhich outputs:\r\n```json\r\n{\r\n  \"__schema\": {\r\n    \"queryType\": {\r\n      \"name\": \"Query\",\r\n      \"fields\": [\r\n        {\r\n          \"name\": \"node\"\r\n        },\r\n        {\r\n          \"name\": \"get\"\r\n        }\r\n      ]\r\n    }\r\n  }\r\n```\r\n\r\n\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}